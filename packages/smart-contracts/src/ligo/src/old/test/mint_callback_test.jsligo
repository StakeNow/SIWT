#import "./balance_of.jsligo" "BalanceOf"
#import "./mint_callback.jsligo" "MintCallback"

const bob = "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address;
const alice = "tz1cQ1mkH1PiCxLUkbWH7SkGj8PrYpffzWxo" as address;
const ursula = "tz1eGd1Gzh9cpZjW1hpzre2fLSnMAsXqRdJy" as address;

const initial_callback_storage = {
  ledger: list([0 as nat]),
  token_contract: bob
};

const initial_storage = {
  ledger: Big_map.literal(
    list([
      [([bob, 0 as nat]), 1 as nat],
      [([alice, 1 as nat]), 1 as nat]
    ])
  );
};

const _balance_of_fa2_contract = () : bool => {
  const [callback_addr, _, _] = Test.originate(MintCallback.main, initial_callback_storage, 0 as tez);
  const _callback_contract = Test.to_contract(callback_addr);

  const balance_of_requests = {
    requests: list([
      {
        owner: bob, //ursula,
        token_id: 0 as nat
      }
    ]),
    callback: Test.to_entrypoint("callback", callback_addr)
  };

  const [t_addr, _, _] = Test.originate(BalanceOf.main, initial_storage, 0 as tez);
  let contr = Test.to_contract(t_addr);
  let _test = Test.transfer_to_contract_exn(contr, (Balance_of(balance_of_requests)), 0 as tez);
  // Test.log(["_", test]);

  let callback_storage = Test.get_storage(callback_addr);
  // Test.log(["CS", callback_storage]);

  return (callback_storage.ledger == list([1 as nat]));
};

const test_balance_of_fa2_contract = _balance_of_fa2_contract();

const _mint = () => {
  // Originate FA2
  const [t_fa2_address, _, _] = Test.originate(BalanceOf.main, initial_storage, 0 as tez);
  const fa2_contract = Test.to_contract(t_fa2_address);
  const fa2_address = Tezos.address(fa2_contract);

  const mint_params = {
    owner: bob,
    token_id: 0 as nat
  };

  const initial_policy_storage = {
    ledger: list([0 as nat]),
    token_contract: fa2_address //Test.nth_bootstrap_contract(1 as nat) //fa2_address
  };
  // Test.log(initial_policy_storage);

  const _mutation = list([{
    request: mint_params,
    balance: 1 as nat
  }]);

// const bco = bootstrap_contract(0 as tez, Balance.main);
  // const [t_fa2_address, _, _] = Test.originate(BalanceOf.main, initial_storage, 0 as tez);
  // let [taddr, _, _] = Test.originate_module(contract_of(MintCallback), initial_policy_storage, 0 as tez);
  // Test.log(["bco", taddr])

  const [t_policy_addr, _, _] = Test.originate(MintCallback.main, initial_policy_storage, 0 as tez);
  const _policy_contract = Test.to_contract(t_policy_addr);

  // const test = Test.transfer_to_contract_exn(policy_contract, (Mint(mint_params)), 0 as tez);
  // Test.log(["Mint", test]);

  const policy_storage = Test.get_storage(t_policy_addr);
  // Test.log(["PS", policy_storage]);

  return (policy_storage == initial_policy_storage);
  // return (policy_storage.ledger == list([1 as nat]));
}
const test_mint = _mint();

/*
const faucet = Test.nth_bootstrap_account(0);
const sender1 : address = Test.nth_bootstrap_account(1);

const initial_storage_mutation = {
  ledger: list([0 as nat]),
  token_contract: sender1
};

const _test_balance_of = (taddr: typed_address<parameter_of MintCallback, MintCallback.storage>, s: address): unit => {
  const contr = Test.to_contract(taddr);
  const contrAddress = Tezos.address(contr);
  const _ = Test.log("contract deployed with values : ");
  const _ = Test.log(contr);
  const _ = Test.log(["sender", s]);
  const _ = Test.log(["contrAddress", contrAddress]);
  // match();
};

const test_mutation = ((): unit => {
  const [taddr, _, _] = Test.originate_module(contract_of(MintCallback), initial_storage_mutation, 0 as tez);
  _test_balance_of(taddr, sender1);
})();
*/
