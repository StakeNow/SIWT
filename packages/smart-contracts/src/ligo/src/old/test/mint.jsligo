type storage_type = {
  ledger: nat,
  token_id: nat,
  contract: address
};

type balance_of_request_type = {
  owner: address,
  token_id: nat
};

type balance_of_response_type = {
  request: balance_of_request_type,
  balance: nat
};

type balance_of_params_type = {
  requests: list<balance_of_request_type>,
  callback: contract<list<balance_of_response_type>>
};

type mint_params = {
  contract: address,
  token_id: nat
};

type action_type =
  | ["Mint"]
  | ["MintCheck", mint_params]
  | ["Callback", list<balance_of_response_type>];

type storage = list<nat>;

type request = {
   owner: address,
   token_id: nat
};

type callback = {
   request: request,
   balance: nat
};

type return_type = [list<operation>, storage];

const _balance_of_callback = (responses: list<callback>, _storage: storage): return_type => {
  const balances: list<nat> = List.map((r: callback): nat => r.balance, responses);
  return [list([]), balances];
};

const callback = (_response: list<balance_of_response_type>, storage: storage_type): [list<operation>, storage_type] => {
  /*
  const _newStorage = {
    ...storage,
    ledger: response.balance
  };
  */

  return [list([]) as list<operation>, storage];
};

const get_contract_balance_of = (params: mint_params, storage: storage_type): [list<operation>, storage_type]  => {
  // const balance_of_opt : option<contract<unit>> = Tezos.get_entrypoint_opt("%balance_of", params.contract);
  // const _token_contract = match(balance_of_opt, {
  //   Some: (contr: contract<unit>) => contr,
  //   None: () => failwith("Error contract entrypoint"),
  // });
  
  // Prepares call to balance_of
  const call_to_balance_of = () : contract<balance_of_params_type> => {
    return match(
      Tezos.get_entrypoint_opt("%balance_of", params.contract) as option<contract<balance_of_params_type>>,
      {
        None: () => failwith("Error contract entrypoint"),
        Some: (contract: contract<balance_of_params_type>) => contract
      }
    );
  };
  
  // Build transaction
  const balance_of_params: balance_of_params_type = {
    requests: list([{
      owner: Tezos.get_sender() as address,
      token_id: params.token_id as nat
    }]),
    callback: Tezos.self("%callback") // as contract<balance_of_response_type> //(Tezos.self("%callback") as contract<balance_of_response_type>)
  };

  const op: operation = Tezos.transaction(
    (balance_of_params),
    // (list([[Tezos.get_sender(), params.token_id]]), Tezos.self("%callback")),
    // (list([[Tezos.get_sender(), params.token_id]]), Tezos.self("%callback") as contract<balance_of_response_type>),
    (0 as mutez),
    call_to_balance_of());

  const _newStorage = {
    ...storage,
    token_id: params.token_id,
    contract: params.contract
  };

  return [list([op]), storage];

  // const op = Tezos.transaction(list([]), (0 as tez), token_contract);

  // const balance_of = match(balance_of_opt, {
  //   Some: (contr: contract<balance_of_response_type>) => Tezos.transaction(list([[Tezos.get_sender(), token_id]]), 0 as tez, contr), //list([[Tezos.get_sender(), params.token_id]])
  //   None: () => failwith(Errors.unknown_contract_entrypoint)
  // });

  /*
  const newStorage = {
    ...storage,
    token_id: params.token_id,
    contract: params.contract
  }

  return [list([]), newStorage];
  */
};

const mint = (storage: storage_type): [list<operation>, storage_type] => {
  const newStorage = {
    ...storage,
    ledger: storage.ledger + (1 as nat)
  };
  return [list([]), newStorage];
};

const main = (action: action_type, storage: storage_type): [list<operation>, storage_type] => {
  return match(action, {
    Mint: () => mint(storage),
    MintCheck: (params: mint_params) => get_contract_balance_of(params, storage),
    Callback: (response) => callback(response, storage)
  });
};

