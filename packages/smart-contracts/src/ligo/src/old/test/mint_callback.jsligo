type storage = {
  ledger: list<nat>,
  token_contract: address
};

type request = {
   owner: address,
   token_id: nat
};

type callback =
  // @layout:comb
  {
    request: request,
    balance: nat
  };

type parameter = list<callback>;

type return_type = [list<operation>, storage];

type mint_params = {
  owner: address,
  token_id: nat
};

type action_type =
  | ["Mint", mint_params]
  | ["Callback", parameter];

type balance_of_params_type = 
  // @layout:comb
  {
    requests: list<request>,
    callback: contract<parameter>
  };

//@no_mutation
//@entry
const callback = (responses: parameter, storage: storage): return_type => {
  let fun = (r: callback): nat => r.balance;

  return [list([]), {
    ...storage,
    ledger: List.map(fun, responses)
  }];
};

//@entry
const get_balance_of = (mint_params: mint_params, storage: storage): return_type => {
  // Prepares call to balance_of
  const token_contract = (): contract<balance_of_params_type> => 
    match(
      Tezos.get_entrypoint_opt("%balance_of", storage.token_contract) as option<contract<balance_of_params_type>>,
      {
        None: () => failwith("Error contract entrypoint"),
        Some: (contract: contract<balance_of_params_type>) => contract
      }
    );

  // const params = {
  //   requests: list([{
  //     owner: Tezos.get_sender() as address,
  //     token_id: params.token_id as nat
  //   }]),
  //   callback: Tezos.get_entrypoint_opt("%callback", Tezos.get_self_address()),
  // };

  const our_callback = match(
    Tezos.get_entrypoint_opt("%callback", Tezos.get_self_address()),
    {
      None: () => failwith("Callback not found"),
      Some: (cb) => cb
    }
  );

  const _params: balance_of_params_type = {
    requests: list([{
      owner: mint_params.owner, // Tezos.get_sender() as address,
      token_id: mint_params.token_id as nat
    }]),
    callback: our_callback
  };

  const _operation = Tezos.transaction(_params, 0 as tez, token_contract());
  // const _operation = Tezos.transaction(_params, 0 as tez, token_contract());

  // return [list([operation]), storage];

  return [list([]), {
    ...storage,
    ledger: list([mint_params.token_id])
  }];
};

//@no_mutation
//@entry
const mint = (mint_params: mint_params, storage: storage): return_type => {
  // Prepares call to balance_of
  const token_contract = (): contract<balance_of_params_type> => 
    match(
      Tezos.get_entrypoint_opt("%balance_of", storage.token_contract) as option<contract<balance_of_params_type>>,
      {
        None: () => failwith("Error contract entrypoint"),
        Some: (contract: contract<balance_of_params_type>) => contract
      }
    );

  // const params = {
  //   requests: list([{
  //     owner: Tezos.get_sender() as address,
  //     token_id: params.token_id as nat
  //   }]),
  //   callback: Tezos.get_entrypoint_opt("%callback", Tezos.get_self_address()),
  // };

  const our_callback = match(
    Tezos.get_entrypoint_opt("%callback", Tezos.get_self_address()),
    {
      None: () => failwith("Callback not found"),
      Some: (cb) => cb
    }
  );

  const params: balance_of_params_type = {
    requests: list([{
      owner: mint_params.owner, // Tezos.get_sender() as address,
      token_id: mint_params.token_id as nat
    }]),
    callback: our_callback
  };

  const operation = Tezos.transaction(params, 0 as tez, token_contract());

  return [list([operation]), storage];
};

const main = (action: action_type, storage: storage): return_type => match(action, {
  Mint: (p) => mint(p, storage),
  Callback: (r) => callback(r, storage)
});
