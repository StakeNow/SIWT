type storage_type =
{
    ledger: big_map<[address, nat], nat>
};

type return_type = [list<operation>, storage_type];

type balance_of_request_type = {
  owner: address,
  token_id: nat,
};

type balance_of_response_type =
  // @layout:comb
  {
    request: balance_of_request_type,
    balance: nat,
  };

type balance_of_params_type =
  // @layout:comb
  {
    requests: list<balance_of_request_type>,
    callback: contract<list<balance_of_response_type>>
  };

type action_type =
| ["Balance_of", balance_of_params_type]
| ["SendValue"];

const balance_of = (params: balance_of_params_type, storage: storage_type): return_type => {
  const responses: list<balance_of_response_type> = List.map(
    (request: balance_of_request_type): balance_of_response_type => {
      const account_balance: nat = match(Big_map.find_opt([request.owner, request.token_id], storage.ledger), {
        None: () => 0 as nat,
        Some: account_balance => account_balance
      });

      const response: balance_of_response_type = { 
          request: request, 
          balance: account_balance 
      };
      return response;
    },
    params.requests
  );

  const callback_operation = Tezos.transaction(responses, 0 as mutez, params.callback);

  return [list([callback_operation]), storage];
};

const main = (action: action_type, storage: storage_type) : return_type => match(action, {
  Balance_of: (p) => balance_of(p, storage),
  SendValue: () => [list([]) as list<operation>, storage]
  // SendValue: (p: unit) => { return [list([]) as list<operation>, storage] }
});
