#import "./storage.jsligo" "Storage"
#import "utils/utils.jsligo" "Utils"
#import "conditions.jsligo" "Conditions"
#import "common/errors.jsligo" "Errors"

type storage = Storage.Types.store;

type policy_params = {
  contract: address,
  token_id: nat,
  policy: bytes,
  signature: signature,
  policy_uri: bytes,
};

type parameter =
  | ["Payout", tez]

type @return = [list<operation>, storage];

// Two entrypoints
const payout = (store: Storage.Types.store, amount: tez): @return => {
  const admin_address = Utils.get_admin(store);
  Conditions.must_be_admin(admin_address);
  Conditions.must_have_enough_balance(amount);

  const receiver : contract<unit> = match (((Tezos.get_contract_opt (admin_address)) as option<contract<unit>>), {
    Some: (contract : contract<unit>) => contract,
    None: () => failwith (Errors.invalid_contract) as contract<unit>
  });

  const op : operation = Tezos.transaction (unit, amount, receiver);
  const operations : list<operation> = list([op]);

  return [operations, store];
};

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
const main = (action: parameter, store: storage) : @return => {
  return match(action, {
    Payout:(p) => payout (store, p)
  });
};