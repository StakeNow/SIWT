#import "./conditions.jsligo" "Conditions"
#import "./storage.jsligo" "Storage"
#import "./utils/utils.jsligo" "Utils"
#import "./common/errors.jsligo" "Errors"

type policy_params = {
  contract: address,
  token_id: nat,
  policy: bytes,
  signature: signature,
  policy_uri: bytes,
};

type request =
  {
    owner: address,
    token_id: nat
  };

type callback =
  // @layout:comb 
  {
    request: request,
    balance: nat
  };

type register_policy_response = list<callback>;

type balance_of_params_type =
  // @layout:comb 
  {
    requests: list<request>,
    callback: contract<list<callback>>
  };

type pricing = map<string, tez>;
type token_metadata = map<string, bytes>;

type action = 
 | ["Mint", policy_params]
 | ["RegisterPolicy", register_policy_response];

type @return = [list<operation>, Storage.Types.store];

const register_policy = (store: Storage.Types.store, responses: register_policy_response): @return => {
  const response: callback = match(List.head_opt(responses), {
    Some: (x) => x,
    None: () => failwith("Incorrect response")
  });

  const newStorage = (response.balance > (0 as nat))
    ? Storage.Utils.test_register_policy(response.request.owner, store)
    : Storage.Utils.remove_temporary_policy(store);

  return [list([]), newStorage];
};

const balance_of_operation = (contract: address, token_id: nat): operation => {
  const token_contract: contract<balance_of_params_type> =
    match(
      Tezos.get_entrypoint_opt("%balance_of", contract) as option<contract<balance_of_params_type>>,
      {
        None: () => failwith(Errors.fa2_balance_of_entrypoint),
        Some: (c: contract<balance_of_params_type>) => c
      }
    );

  const register_policy_callback: contract<register_policy_response> = match(
    Tezos.get_entrypoint_opt("%registerPolicy", Tezos.get_self_address()),
    {
      None: () => failwith(Errors.register_policy_entrypoint),
      Some: (cb) => cb
    }
  );

  const balance_of_params = {
    requests: list([{
      owner: Tezos.get_sender() as address,
      token_id: token_id as nat
    }]),
    callback: register_policy_callback
  };

  return Tezos.transaction(balance_of_params, 0 as tez, token_contract);
};

const mint = (store: Storage.Types.store, params: policy_params): @return => {
  Conditions.signature_must_be_valid(store.admin.verifier, params.signature, params.policy);
  // const price = get_policy_price(store, params.policy);
  // Conditions.amount_must_be_subscription_value((Tezos.get_amount(), price));
  Conditions.requested_token_contract_must_be_allowed(params.contract, store.allowed_token_contracts);

  const newStorage = Storage.Utils.add_temporary_policy(
    Tezos.get_sender(),
    {
      policy: params.policy,
      policy_uri: params.policy_uri,
    } as Storage.Types.temporary_policy,
    store
  );

  // Prepares call to balance_of
  const operation = balance_of_operation(params.contract, params.token_id);

  return [list([operation]), newStorage];
};

const main = (action: action, store: Storage.Types.store) : @return => 
  match(action, {
    Mint: (params) => mint(store, params),
    RegisterPolicy: (responses: register_policy_response) => register_policy(store, responses),
  });


/*
const token_contract: contract<balance_of_params_type> =
  match(
    Tezos.get_entrypoint_opt("%balance_of", params.contract) as option<contract<balance_of_params_type>>,
    {
      None: () => failwith(Errors.fa2_balance_of_entrypoint),
      Some: (contract: contract<balance_of_params_type>) => contract
    }
  );

const register_policy_callback = match(
  Tezos.get_entrypoint_opt("%registerPolicy", Tezos.get_self_address()),
  {
    None: () => failwith(Errors.register_policy_entrypoint),
    Some: (cb) => cb
  }
);

const _params: balance_of_params_type = {
  requests: list([{
    owner: Tezos.get_sender() as address,
    token_id: params.token_id as nat
  }]),
  callback: register_policy_callback
};

const operation = Tezos.transaction({
  requests: list([{
    owner: Tezos.get_sender() as address,
    token_id: params.token_id as nat
  }]),
  callback: register_policy_callback
}, 0 as tez, token_contract);
*/