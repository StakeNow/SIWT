/*
 * Copyright (C) 2022, vDL Digital Ventures GmbH <info@vdl.digital>
 *
 * SPDX-License-Identifier: MIT
 */

const transfer = ([t, s]: [transfer, storage]): [list<operation>, storage] => {
   const process_atomic_transfer = (from_ : address) 
   : (ledger: Ledger.t, t: atomic_trans) => Ledger.t => {
     return (ledger: Ledger.t, t: atomic_trans) : Ledger.t => {
        const {to_,token_id} = t;
        Storage.assert_token_exist (s, token_id);
        Operators.assert_authorisation (s.operators, from_, token_id);
        const ledger = Ledger.transfer_token_from_user_to_user (ledger, token_id, from_, to_);
        ledger
     };
   }; 
   const process_single_transfer = ([ledger, t]: [Ledger.t, transfer_from]) : Ledger.t => {
      const {from_,tx} = t;
      const ledger     = List.fold_left (process_atomic_transfer (from_), ledger, tx);
      ledger
   };
   const ledger = List.fold_left (process_single_transfer, s.ledger, t);
   const s = Storage.set_ledger (s, ledger);
   [list ([]),s]
};

const balance_of = ([b, s] : [balance_of, storage]): [list<operation>, storage] => {
   const {requests, callback} = b;
   const get_balance_info = (request : request) : callback => {
      const {owner,token_id} = request;
      Storage.assert_token_exist  (s, token_id); 
      let balance_ = 0 as nat;
      if (Storage.is_owner_of (s, owner, token_id)) balance_ = 1 as nat;
      ({request:request,balance:balance_})
   };
   const callback_param = List.map (get_balance_info, requests);
   const operation = Tezos.transaction (callback_param, (0 as tez), callback);
   [list([operation]),s]
};

const update_ops = ([updates, s]: [update_operators, storage]): [list<operation>, storage] => {
   const update_operator = ([operators,update] : [Operators.t, unit_update]) : Operators.t => match (update, 
   { Add_operator    : (operator: operator) => Operators.add_operator (operators, operator.owner, operator.operator, operator.token_id)
   , Remove_operator : (operator: operator) => Operators.remove_operator (operators, operator.owner, operator.operator, operator.token_id)
   });
   let operators = Storage.get_operators (s);
   operators = List.fold_left (update_operator, operators, updates);
   const s = Storage.set_operators (s, operators);
   [list([]),s]
};

namespace Operators {
   type owner    = address;
   type operator = address;
   type token_id = nat;
   export type t = big_map<[owner, operator], set<token_id>>;

   export const assert_authorisation = ([operators, from_, token_id]: [t, address, nat]): unit => {
      const sender_ = (Tezos.get_sender ());
      if (sender_ != from_){
         const authorized = match ((Big_map.find_opt ([from_,sender_], operators)),
         {Some: (a : set<token_id>) => a , None : () => Set.empty});
         if (!(Set.mem (token_id, authorized))) 
            {return failwith (Errors.not_operator)}
      }
   };

   export const is_operator = ([operators, owner, operator, token_id] : [t , address , address , nat]) : bool => {
      const authorized = match (Big_map.find_opt ([owner, operator], operators),
      {Some: (a : set<token_id>) => a , None : () => Set.empty});
      (Set.mem (token_id, authorized) || owner == operator)  
   };

   const assert_update_permission = (owner : owner) : unit =>
      assert_with_error ((owner == (Tezos.get_sender ())), "The sender can only manage operators for his own token");

   export const add_operator = ([operators,owner,operator,token_id]: [t, owner, operator, token_id]) : t => {
      if (owner == operator) { return operators; }
      else {
         assert_update_permission (owner);
         let auth_tokens = match (Big_map.find_opt ([owner,operator], operators),
            {Some : (ts: set<token_id>) => ts , None : () => Set.empty});
         auth_tokens = Set.add (token_id, auth_tokens);
         return Big_map.update ([owner,operator], Some (auth_tokens), operators);
      }
   };
         
   export const remove_operator = ([operators,owner,operator,token_id]: [t, owner, operator, token_id]) : t => {
      if (owner == operator) { return operators; }
      else {
         assert_update_permission (owner);
         const auth_tokens : option<set<token_id>> = match (Big_map.find_opt ([owner,operator], operators),
         {Some : (ts : set<token_id>) => {
            const ts = Set.remove (token_id, ts);
            if (Set.cardinal (ts) == (0 as nat)) { return None ()} else { return Some (ts)};
          },
          None : () => None ()
         });
         return Big_map.update ([owner,operator], auth_tokens, operators);
      }
   };
};
